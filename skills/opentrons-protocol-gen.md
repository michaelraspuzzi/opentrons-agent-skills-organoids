---
name: opentrons-protocol-gen
description: Generate executable Python protocols for Opentrons Flex liquid handling robot. Takes experimental designs from hypothesis generation and produces ready-to-run code with plate layouts, reagent calculations, and safety checks.
---

# Opentrons Protocol Generation

Transform experimental designs into executable Opentrons Flex Python protocols.

## Input Modes

### Mode 1: Structured Input (from hypothesis skill)
Accepts JSON with experimental design from `hypothesis-generation` skill.

### Mode 2: Natural Language
User describes experiment directly:
- "Set up a dose-response with 8 concentrations of doxorubicin, N=4"
- "Serial dilution from 100 µM to 0.1 µM, half-log steps"

### Mode 3: Plate Layout First
User provides or requests plate layout, then generates protocol to execute it.

## Protocol Generation Workflow

### Step 1: Parse Experimental Design
Extract groups, replicates, plate format, volumes, timing requirements.

### Step 2: Select Pipette Configuration

**CRITICAL - Pipette Selection Rules:**

| Well Access Pattern | Pipette Type | Example |
|---------------------|--------------|---------|
| Individual scattered wells | `flex_1channel_1000` | A1, A2, B5, C3 |
| Entire columns (A-H) | `flex_8channel_1000` | All of column 1 |
| Whole plate operations | `flex_96channel_1000` | Plate stamping |

**Common Error:** Using 8-channel with `wells_by_name()['A1']` will dispense to entire column A1-H1!

### Step 3: Design Plate Layout
Create visual plate map. Layout principles:
- Controls on edges or distributed
- Replicates in adjacent wells for multichannel
- Leave columns for serial dilution source

### Step 4: Calculate Reagents
For each reagent:
- Total volume = wells × volume × 1.2 overage
- Include dead volume for reservoirs

### Step 5: Plan Deck Layout
Assign deck positions for tips, reservoirs, plates, modules.

### Step 6: Generate Protocol Code

**Required Elements for Flex:**

```python
from opentrons import protocol_api

metadata = {
    'protocolName': '[Name]',
    'author': 'Generated by Claude',
    'description': '[Description]'
}

requirements = {
    'robotType': 'Flex',
    'apiLevel': '2.16'
}

def run(protocol: protocol_api.ProtocolContext):
    # Load trash bin (REQUIRED for Flex)
    trash = protocol.load_trash_bin('A3')

    # Load labware
    tips = protocol.load_labware('opentrons_flex_96_tiprack_1000ul', 'A1')

    # Load pipette (choose based on well access pattern)
    pipette = protocol.load_instrument(
        'flex_1channel_1000',  # or flex_8channel_1000
        'right',
        tip_racks=[tips]
    )
```

**NEVER put apiLevel in both metadata and requirements - only in requirements!**

### Step 7: Output Package
Generate:
1. Python protocol file (.py)
2. Plate map (markdown table)
3. Reagent preparation guide

## Critical Validation Rules

### Pipette-Layout Compatibility
```
IF wells are scattered (different rows in same column):
    USE flex_1channel_1000

IF entire columns get same treatment:
    USE flex_8channel_1000 with .columns()
```

### Volume Capacity
```
Each aspirate ≤ pipette max capacity (1000 µL)
Cumulative aspirates before drop_tip ≤ capacity
```

### Flex Requirements
- `requirements` dict with `robotType: 'Flex'` and `apiLevel: '2.16'`
- Trash bin explicitly loaded: `protocol.load_trash_bin('A3')`
- Use Flex-specific labware: `opentrons_flex_96_tiprack_*`

## Quality Checklist

Before finalizing protocol:

- [ ] apiLevel in requirements dict ONLY (not in metadata)
- [ ] Trash bin loaded for Flex
- [ ] Pipette type matches well access pattern
- [ ] All volumes within pipette range
- [ ] Tip count sufficient
- [ ] Deck layout has no conflicts
- [ ] Comments explain each step

## Common Pitfalls

### ❌ 8-Channel with Individual Wells
```python
# WRONG - will dispense to entire column
p8_200.dispense(100, plate.wells_by_name()['A1'])

# CORRECT for 8-channel
p8_200.dispense(100, plate.columns()[0])

# CORRECT for individual wells - use single channel
p1000.dispense(100, plate.wells_by_name()['A1'])
```

### ❌ Duplicate apiLevel
```python
# WRONG
metadata = {'apiLevel': '2.16'}
requirements = {'apiLevel': '2.16'}

# CORRECT
metadata = {'protocolName': '...'}
requirements = {'robotType': 'Flex', 'apiLevel': '2.16'}
```

### ❌ Missing Trash Bin
```python
# WRONG - will error on drop_tip()
def run(protocol):
    tips = protocol.load_labware(...)
    pipette.drop_tip()  # Error: No trash defined!

# CORRECT
def run(protocol):
    trash = protocol.load_trash_bin('A3')  # Required!
    tips = protocol.load_labware(...)
```

## Testing Protocol

Always test with simulator before running on hardware:
```bash
opentrons_simulate your_protocol.py
```

Simulator will catch:
- Missing trash bin
- Invalid labware
- Volume errors
- API errors
